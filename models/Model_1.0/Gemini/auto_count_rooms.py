import os
import pandas as pd
import numpy as np
import cv2 # OpenCV for image processing and connected components
import logging
from tqdm import tqdm # Progress bar

# --- Configuration ---

# Input Metadata CSV file (the one generated by step 1.1-1.2)
INPUT_METADATA_FILENAME = "floor_plan_metadata_v3.csv" # <<< Use the latest correct CSV

# Output Metadata CSV file (with counts filled in)
OUTPUT_METADATA_FILENAME = "floor_plan_metadata_v3_counts.csv" # <<< Save to a new file

# Base directory where '5_marla', '10_marla' etc. subfolders reside
BASE_DATA_DIR = "./dataset"

# Minimum pixel area for a region to be counted (helps filter noise)
# Adjust this value based on your image resolution and noise level.
# Start small (e.g., 10-50 pixels) and increase if it counts tiny dots.
MIN_AREA_THRESHOLD = 80

# --- Color Mapping and Room Definitions ---
# (Copied from step 1.3-1.5 script for consistency)
COLOR_TO_ID_MAP = {
    # --- Structural ---
    (0, 0, 0): 0,        # Walls (Black)
    (128, 0, 0): 22,     # Door (Mahogany)

    # --- Rooms & Areas ---
    (255, 0, 0): 1,      # Bedroom (Red)
    (0, 0, 255): 2,      # Bathroom (Blue)
    (255, 165, 0): 3,    # Kitchen (Orange)
    (0, 128, 0): 4,      # Drawing Room (Green)
    (165, 42, 42): 5,    # Garage (Brown)
    (255, 255, 0): 6,    # Lounge/Sitting Area (Yellow)
    (50, 205, 50): 7,    # Backyard (Lime Green)
    (0, 128, 128): 8,    # Stairs (Teal)
    (128, 0, 128): 9,    # Storage Room/Store (Purple)
    (0, 255, 255): 10,   # Open Space (Cyan)
    (127, 127, 127): 11, # Prayer Room (Grayish/Check RGB)
    (153, 51, 255): 12,  # Staircase (Violet)
    (255, 0, 255): 13,   # Lobby (Magenta)
    (64, 224, 208): 14,  # Lawn (Turquoise)
    (225, 192, 203): 15, # Dining (Pink)
    (75, 0, 130): 16,    # Servant Quarters (Indigo)
    (128, 128, 0): 17,   # Passage (Olive Green)
    (230, 230, 250): 18, # Laundry (Lavender)
    (255, 127, 80): 19,  # Dressing Area (Coral)
    (255, 215, 0): 20,   # Side Garden (Gold)
    (255, 191, 0): 21,   # Library (Amber)
}

# List of room types whose counts we want to update in the CSV
# Should match the 'Count_*' column names derived previously (excluding Walls/Door)
ROOM_TYPES_TO_COUNT = [
    'Bedroom', 'Bathroom', 'Kitchen', 'Drawing Room', 'Garage',
    'Lounge/Sitting Area', 'Backyard', 'Stairs', 'Storage Room/Store',
    'Open Space', 'Prayer Room', 'Staircase', 'Lobby', 'Lawn', 'Dining',
    'Servant Quarters', 'Passage', 'Laundry', 'Dressing Area',
    'Side Garden', 'Library', 'Amber',
]

# Create a mapping from Room Name -> Class ID for easier lookup
# Reverse the main map first: ID -> RGB
ID_TO_COLOR_MAP_REV = {v: k for k, v in COLOR_TO_ID_MAP.items()}
# Find the ID for each room name we care about
ROOM_NAME_TO_ID_MAP = {}
for room_name in ROOM_TYPES_TO_COUNT:
    found = False
    # This lookup is a bit inefficient, but clear. Assumes color names in the original spec match ROOM_TYPES list.
    # We might need a direct Name -> RGB -> ID mapping if names differ.
    # For now, assuming standard names from the provided list map to the IDs.
    # Example: Find ID for 'Bedroom' (which is Red, RGB(255,0,0), ID 1)
    target_rgb = None
    # Manual mapping based on the provided color list to avoid ambiguity
    name_to_rgb_lookup = {
        'Bedroom': (255, 0, 0), 'Bathroom': (0, 0, 255), 'Kitchen': (255, 165, 0),
        'Drawing Room': (0, 128, 0), 'Garage': (165, 42, 42), 'Lounge/Sitting Area': (255, 255, 0),
        'Backyard': (50, 205, 50), 'Stairs': (0, 128, 128), 'Storage Room/Store': (128, 0, 128),
        'Open Space': (0, 255, 255), 'Prayer Room': (127, 127, 127), 'Staircase': (153, 51, 255),
        'Lobby': (255, 0, 255), 'Lawn': (64, 224, 208), 'Dining': (225, 192, 203),
        'Servant Quarters': (75, 0, 130), 'Passage': (128, 128, 0), 'Laundry': (230, 230, 250),
        'Dressing Area': (255, 127, 80), 'Side Garden': (255, 215, 0), 'Library': (255, 191, 0),
        'Amber': (255, 191, 0) # Note: Amber and Library have same color in the list provided
    }
    target_rgb = name_to_rgb_lookup.get(room_name)

    if target_rgb:
        for rgb, id_val in COLOR_TO_ID_MAP.items():
            if rgb == target_rgb:
                ROOM_NAME_TO_ID_MAP[room_name] = id_val
                found = True
                break
    if not found:
         logging.warning(f"Could not find a Class ID mapping for room type: '{room_name}'. It will not be counted.")


# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Room Counting Function ---

def count_regions_for_image(image_path, color_to_id_map, room_name_to_id_map, min_area_threshold):
    """
    Loads an image, performs connected components analysis for each specified
    room type color, and returns the counts of distinct regions above a threshold.

    Args:
        image_path (str): Path to the floor plan image.
        color_to_id_map (dict): Map from RGB tuple to class ID.
        room_name_to_id_map (dict): Map from Room Name (string) to class ID.
        min_area_threshold (int): Minimum area in pixels for a region to be counted.

    Returns:
        dict: A dictionary mapping room names (str) to their counts (int),
              or None if the image cannot be processed.
    """
    try:
        # Load image using OpenCV (keeps color order BGR by default)
        img_bgr = cv2.imread(image_path)
        if img_bgr is None:
            raise FileNotFoundError(f"Image not found or could not be loaded: {image_path}")

        # Convert BGR to RGB for consistency with our COLOR_TO_ID_MAP
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        height, width, _ = img_rgb.shape

        # --- Create Segmentation Mask (similar to Dataset preproc) ---
        segmentation_mask = np.zeros((height, width), dtype=np.int32) # Use int32 for labels
        for rgb_tuple, class_id in color_to_id_map.items():
            # Need to compare across the color channel (axis=2)
            matches = np.all(img_rgb == np.array(rgb_tuple).reshape(1, 1, 3), axis=2)
            segmentation_mask[matches] = class_id

        # --- Count Regions for Each Room Type ---
        room_counts = {room_name: 0 for room_name in room_name_to_id_map.keys()}

        for room_name, target_id in room_name_to_id_map.items():
            # Create a binary mask for the current room type ID
            binary_mask = (segmentation_mask == target_id).astype(np.uint8)

            # Find connected components
            # connectivity=8 means pixels are connected if they touch sides or corners
            num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(binary_mask, connectivity=8)

            # Iterate through components found (label 0 is the background)
            count_for_room = 0
            for i in range(1, num_labels): # Start from 1 to exclude background
                area = stats[i, cv2.CC_STAT_AREA]
                if area >= min_area_threshold:
                    count_for_room += 1

            room_counts[room_name] = count_for_room
            # logging.debug(f"  {room_name} (ID {target_id}): Found {count_for_room} regions >= {min_area_threshold}px area.")

        return room_counts

    except FileNotFoundError as e:
        logging.error(f"Skipping - {e}")
        return None
    except Exception as e:
        logging.error(f"Error processing image {os.path.basename(image_path)}: {e}", exc_info=False) # Set exc_info=True for full traceback
        return None


# --- Main Script Logic ---
if __name__ == "__main__":
    logging.info(f"--- Starting Room Counting Script ---")
    logging.info(f"Loading metadata from: {INPUT_METADATA_FILENAME}")

    try:
        df = pd.read_csv(INPUT_METADATA_FILENAME)
        logging.info(f"Loaded {len(df)} records.")
    except FileNotFoundError:
        logging.error(f"FATAL: Input metadata file not found: {INPUT_METADATA_FILENAME}")
        exit()
    except Exception as e:
        logging.error(f"FATAL: Error loading CSV: {e}")
        exit()

    # Verify expected count columns exist
    missing_cols = []
    for room_name in ROOM_TYPES_TO_COUNT:
        col_name = f'Count_{room_name}'
        if col_name not in df.columns:
            missing_cols.append(col_name)
    if missing_cols:
        logging.error(f"FATAL: Metadata CSV is missing required count columns: {missing_cols}")
        exit()

    logging.info(f"Processing images and counting rooms (Min Area: {MIN_AREA_THRESHOLD}px)...")

    processed_count = 0
    error_count = 0

    # Iterate through the DataFrame rows with a progress bar
    for index, row in tqdm(df.iterrows(), total=len(df), desc="Counting Rooms"):
        relative_path = row['RelativePath']
        full_image_path = os.path.join(BASE_DATA_DIR, relative_path)

        # Ensure path separators are correct for the OS
        full_image_path = os.path.normpath(full_image_path)

        logging.debug(f"Processing index {index}: {full_image_path}") # DEBUG log

        # Call the counting function
        counts = count_regions_for_image(
            full_image_path,
            COLOR_TO_ID_MAP,
            ROOM_NAME_TO_ID_MAP,
            MIN_AREA_THRESHOLD
        )

        if counts is not None:
            processed_count += 1
            # Update the DataFrame row with the counts
            for room_name, count_value in counts.items():
                col_name = f'Count_{room_name}'
                # Use .loc for safe assignment
                df.loc[index, col_name] = count_value
        else:
            error_count += 1
            # Optionally: fill errored rows with a specific value like -1?
            # for room_name in ROOM_TYPES_TO_COUNT:
            #     col_name = f'Count_{room_name}'
            #     df.loc[index, col_name] = -1 # Mark as error

    logging.info(f"--- Counting Complete ---")
    logging.info(f"Successfully processed: {processed_count} images")
    logging.info(f"Errors encountered: {error_count} images")

    # --- Save Updated DataFrame ---
    try:
        df.to_csv(OUTPUT_METADATA_FILENAME, index=False, encoding='utf-8')
        logging.info(f"Updated metadata saved to: {OUTPUT_METADATA_FILENAME}")
    except Exception as e:
        logging.error(f"FATAL: Error saving updated CSV: {e}")

    logging.info("--- Script Finished ---")